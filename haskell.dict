main
module
import
qualified
as
type
data
class
instance
newtype
deriving
do
let
in
where
case
of
if
then
else
otherwise
Prelude
(1/)
(/2)
(::)
(=>)
(->)
(<-)
(++)
(!!)
($)
(.)
(>>)
(>>=)
Maybe
Just
Nothing
Char
String
Int
Integer
Bool
True
False
Float
undefined
curry
uncurry
return v
pure v
const v v'
id v
show
read
words
unwords xs
lines
unlines xs
getChar
getLine
getContents
putChar
putStrLn
print
map f xs
fmap f xs
foldl f a xs
foldr f a xs
zip xs ys
unzip
zipWith f xs ys
span p xs
break p xs
lookup a ts
filter p xs
any p xs
all p xs
null xs
head xs
tail xs
init xs
last xs
length xs
reverse xs
take n xs
takeWhile p xs
drop n xs
dropWhile p xs
concat xss
repeat xs
cycle xs
replicate n a
iterate f a
sum xs
product xs
maximum xs
minimum xs
max l r
min l r
maxBound :: Int
minBound :: Int
(**)
(^)
sqrt
abs
elem
notElem
(&&)
(||)
(/=)
(==)
(>=)
(<=)
(>)
(<)
or
and
odd
even
pred
succ
mod
div
fst t
snd t
flip f x y
truncate
round
floor
ceiling

System.IO
isEOF

Data.List.Split
splitOn a as

Data.Ord
comparing

Control.Applicative
(<$>)
(<*>)

Control.Monad
replicateM
replicateM_
forM
forM_

Data.Array
(!)
(//)
Array
array
listArray

Data.List
nub xs
permutations xs
subsequences xs
sort xs
sortBy (comparing snd) xs
group xs
maximumBy
findIndex p xs
unfoldr

Data.Char
chr
ord
